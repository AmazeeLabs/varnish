<?php
// $Id:

define (VARNISH_NO_CLEAR, 0);
define (VARNISH_DEFAULT_CLEAR, 1);
define (VARNISH_SELECTIVE_CLEAR, 2);
define (VARNISH_COOKIE_NAME, 'VARNISH');


/**
 * @file varnish.module
 * Provide drupal hooks for integration with the Varnish control layer.
 */
 
 function varnish_init() {
   global $user;
 }

/**
 * Implementation of hook_menu()
 *
 * Set up admin settings callbacks, etc.
 */
function varnish_menu() {
  $items = array();
  $items['admin/settings/varnish'] = array(
    'title' => 'Varnish settings',
    'description' => 'Configure your varnish integration.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('varnish_admin_settings_form'),
    'access arguments' => array('administer varnish'),
    'file' => 'varnish.admin.inc',
  );
  $items['admin/reports/varnish'] = array(
    'title' => 'Varnish status',
    'description' => 'Configure your varnish integration.',
    'page callback' => 'varnish_admin_reports_page',
    'access arguments' => array('administer varnish'),
    'file' => 'varnish.admin.inc',
  );
  return $items;
}

/** 
 * Implemetation of hook_perm()
 *
 * Allows admins to control access to varnish settings.
 */
function varnish_perm() {
  return array('administer varnish');
}

/**
 * Implementation of hook_requirements()
 *
 * Insure that varnish's connection is good.
 */
function varnish_requirements($phase) {
  if ($phase == 'runtime') {
    $requirements = array('varnish');
    $requirements['varnish']['title'] = t('Varnish status');
    // try a varnish admin connect, report results
    $status = _varnish_terminal_run('status', 300);
    if (strpos($status, 'Child in state running') === FALSE) {
      $requirements['varnish']['value'] = t('Varnish connection broken');
      $requirements['varnish']['severity'] = REQUIREMENT_ERROR;
      $requirements['varnish']['description'] = t('The Varnish control terminal is not responding at %server on port %port.', array('%server' => variable_get('varnish_control_terminal_server', '127.0.0.1'), '%port' => variable_get('varnish_control_terminal_port', '6082')));
    }
    else {
      $requirements['varnish']['value'] = t('Varnish runing. Observe more detailed statistics !link.', array('!link' => l(t('here'), 'admin/reports/varnish')));
    }
    return $requirements;
  }
}

/**
 * Implementation of hook_nodeapi()
 *
 * Used to pick up cache_clearing events
 */
function varnish_nodeapi(&$node, $op) {
  if ($op == 'insert' || $op == 'update') {
    // We've probably just run through node_save, and normally this is where
    // Drupal calls a cache_clear_all().
    switch (variable_get('varnish_cache_clear', VARNISH_DEFAULT_CLEAR)) {
      case VARNISH_DEFAULT_CLEAR:
        _varnish_terminal_run('purge.hash .*');
        break;
      case VARNISH_SELECTIVE_CLEAR:
        $selective_urls = str_replace('<front>', "/\n". variable_get('site_frontpage', 'node'), variable_get('varnish_cache_clear_urls', '<front>'));
        $urls = explode("\n", $selective_urls);
        $urls = array_merge($urls, varnish_get_active_urls($node));
        $purge = implode('$|^/', $urls);
         _varnish_terminal_run('purge req.url ~ "^'. $purge .'$"');
        break;
    }
    
  }
}

/**
 * Implementation of hook_cache_flush()
 *
 * Respect the big cache flush.
 */
function varnish_flush_caches() {
  _varnish_terminal_run('purge.hash .*');
}

/**
 * Extensible logic function to get other urls to clear.
 *
 * TODO: Merge this with boost logic.
 */
function varnish_get_active_urls($node) {
  $urls = array();
  $urls[] = 'node/'. $node->nid;
  if ($node->type == 'blog') {
    $urls[] = 'blog';
    $urls[] = 'blog/'. $node->uid;
  }
    // lots more here...
  foreach($urls as $url) {
    $alias = drupal_get_path_alias($url); // TODO: languages?
    if ($alias != $url) {
      $urls[] = $alias;
    }
  }
  return $urls;
}


/**
 * Helper function that sends commands to Varnish
 *
 * Utilizes sockets to talk to varnish terminal.
 */
function _varnish_terminal_run($command, $returnlength = 1000) {
  if (!extension_loaded('sockets')) {
    drupal_set_message(t('Sockets extension not enabled. Varnish terminal communication aborted.'), 'error');
    return FALSE;
  }
  $server = variable_get('varnish_control_terminal_server', '127.0.0.1');
  $port = variable_get('varnish_control_terminal_port', '6082');

  
  $client = socket_create(AF_INET, SOCK_STREAM, getprotobyname('tcp'));
  if (!socket_connect($client, $server, $port)) {
    watchdog('varnish', t('Unable to connect to server socket !server:!port', array('!server' => $server, '!port' => $port)));
    return FALSE;
  }
  socket_write($client, "$command\n");
  $code = socket_read($client, 3, PHP_BINARY_READ);
  if ($code != 200) {
    $error = socket_read($client, 3000, PHP_BINARY_READ);
    watchdog('varnish', t('Recieved status code !code running !command. Full response text: !error', array('!code' => $code, '!command' => $command, '!error' => $error)));
    $ret = FALSE;
  }
  else {
    // successful connection
    $ret = socket_read($client, $returnlength, PHP_BINARY_READ);
  }
  socket_close($client);
  
  return $ret;
}


/**
 * Implementaiton of hook_user()
 *
 * This sets/removes a special cookie on login/logout so that a sysadmin can 
 * develop a VCL file that isn't entirely dependent on the session cookie to
 * determine whether or not to serve a page from cache.
 */
function varnish_user($op, &$edit, &$account, $category = NULL) {
  if (variable_get('varnish_special_cookie', 0) == 1 && $op == 'login') {
    _varnish_set_cookie($account); 
  }
  if (variable_get('varnish_special_cookie', 0) == 1 && $op == 'logout') {
    _varnish_remove_cookie($account);
  }
}

/**
 * Remove our cookie.
 */
function _varnish_remove_cookie() {
  $expires = -1;
  setcookie(VARNISH_COOKIE_NAME, NULL, $expires, ini_get('session.cookie_path'), ini_get('session.cookie_domain')); 
}

/**
 * Set our cookie.
 */
function _varnish_set_cookie($account) {
  $expires = time() + ini_get('session.cookie_lifetime'); 
  setcookie(VARNISH_COOKIE_NAME, $account->uid, $expires, ini_get('session.cookie_path'), ini_get('session.cookie_domain'));
}